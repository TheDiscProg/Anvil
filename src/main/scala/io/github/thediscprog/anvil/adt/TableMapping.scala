package io.github.thediscprog.anvil.adt

import java.sql.Connection
import scala.deriving.Mirror
import scala.annotation.nowarn
import java.sql.ResultSet
import java.sql.JDBCType
import cats.Monad
import cats.implicits.*
import org.typelevel.log4cats.Logger
import java.sql.PreparedStatement
import java.sql.ResultSetMetaData
import io.github.thediscprog.anvil.caching.Memoize
import io.github.thediscprog.anvil.caching.CaffeineMemoize
import io.github.thediscprog.anvil.annotations.PrimaryKeyAnnotation
import io.github.thediscprog.anvil.dialects.SqlDialect
import io.github.thediscprog.anvil.macros.ProductMacro.*

sealed trait TableMapping[F[_], A <: Product](
    val properties: TableProperties,
    val connection: Connection
) {

  def transactional[R](f: () => F[R]): F[R]

  infix def /~>(criteria: Criteria): F[List[A]] = filter(criteria)

  infix def /->(criteria: Criteria): F[List[A]] = filter(criteria, true)

  infix def /?(criteria: Criteria): F[Option[A]] = headOption(criteria)

  infix def <+(a: A): F[Int] = add(a)

  infix def filterDistinct(criteria: Criteria): F[List[A]] = filter(criteria)

  infix def filter(criteria: Criteria, distinct: Boolean = false): F[List[A]]

  infix def headOption(criteria: Criteria): F[Option[A]]

  infix def add(a: A): F[Int]

}

object TableMapping {
  import JDBCBinder.*

  @nowarn
  inline def getTableReader[F[_]: Monad: Logger, A <: Product](
      tableProps: TableProperties,
      dbConnection: Connection
  )(using m: Mirror.ProductOf[A]): TableMapping[F, A] = {

    new TableMapping[F, A](tableProps, dbConnection) {

      val primaryKey = PrimaryKeyAnnotation.getPrimaryKeyNames[A]

      val dialect = SqlDialect.getDialect(tableProps.dialect)

      val memoize: CaffeineMemoize[F] = Memoize.getMemoizeFunction[F]

      override def transactional[R](f: () => F[R]): F[R] =
        for {
          _ <- Logger[F].debug(
            s"* * * TableMapping: Running Transactional on ${properties.table} using ${properties.dialect} * * *"
          )
          autoCommitFlag = connection.getAutoCommit()
          _              = connection.setAutoCommit(false)
          result <- f()
          _ = connection.commit()
          _ = connection.setAutoCommit(autoCommitFlag)
          _ <- Logger[F].debug(
            s"* * * TableMapping: Finished Transactional on ${properties.table} using ${properties.dialect} * * *"
          )
        } yield result

      override def add(a: A): F[Int] = {
        val columns            = getColumnLabels(primaryKey.autoGenerated)
        val values: Array[Any] = getProductValues(a)
        val insertStmt = dialect.insert(columns, tableProps.table, values)
        for {
          _ <- Logger[F].debug(
            s"* * * TableMapping: Insert on ${properties.table} using ${properties.dialect} * * *"
          )
          stmt <- (connection.prepareStatement(insertStmt)).pure[F]
          _    <- (bindParameters(stmt, values.toList, connection, dialect))
            .pure[F]
          result <- (stmt.executeUpdate()).pure[F]
          _ <- Logger[F].debug(s"* * * TableMapping: Insert Finished * * *")
        } yield result
      }

      private def getProductValues(a: A): Array[Any] = {
        if (primaryKey.autoGenerated) {
          getProductValuesWithoutPK(a)
        } else {
          a.productIterator.toArray
        }
      }

      private def getProductValuesWithoutPK(a: A): Array[Any] = {
        val names  = fieldNamesOf[A]
        val values = a.productIterator.toList
        names
          .zip(values)
          .filterNot { case (name, _) => primaryKey.columnNames.contains(name) }
          .map(_._2)
          .toArray
      }

      override def headOption(criteria: Criteria): F[Option[A]] =
        for {
          _ <- Logger[F].debug(
            s"* * * TableMapping: Running getOne on ${properties.table} using ${properties.dialect} * * *"
          )
          aList <- filter(criteria)
          result = aList match
            case head :: next => Some(head)
            case Nil          => None
          _ <- Logger[F].debug(
            s"* * * TableMapping: Finished running getOne on ${properties.table} * * *"
          )
        } yield result

      override def filter(
          criteria: Criteria,
          distinct: Boolean = false
      ): F[List[A]] =
        for {
          _ <- Logger[F].debug(
            s"* * * TableMapping: Filter on ${properties.table} using ${properties.dialect} * * *"
          )
          columns = getColumnLabels()
          _ <- Logger[F].debug(s"TableMapping: Columns: [$columns]")
          whereClause     = Criteria.getWhereClause(criteria.criteria)
          selectStatement =
            if (distinct)
              dialect.filterDistinct(columns, properties.table, whereClause._1)
            else
              dialect.filter(columns, properties.table, whereClause._1)
          _ <- Logger[F].info(
            s"* * * * TableMapping: Table: [${properties.table}]: Query: [$selectStatement]"
          )
          statement: PreparedStatement = connection.prepareStatement(
            selectStatement
          )
          _ = bindParameters(statement, whereClause._2, connection, dialect)
          metadata <- getResultSetMetaData(statement)
          resultSet         = statement.executeQuery()
          columnDescriptors = ColumnDescriptor.getColumnInformation(metadata)
          result <- convertResultSet(columnDescriptors.toList, resultSet)
            .pure[F]
          _ <- Logger[F].debug(
            s"* * * TableMapping: Finished Filter on ${properties.table} * * *"
          )
        } yield result

      private def getResultSetMetaData(
          sttm: PreparedStatement
      ): F[ResultSetMetaData] =
        memoize.memoize(properties.cachingKey)(_ => sttm.getMetaData().pure[F])

      private def convertResultSet(
          columnDescriptors: List[ColumnDescriptor],
          resultSet: ResultSet
      ): List[A] = {
        def loop(acc: List[A], rs: ResultSet): List[A] = {
          if (!rs.next()) acc
          else {
            val row = mapToScala(columnDescriptors, rs)
            loop(row :: acc, rs)
          }
        }
        loop(List(), resultSet)
      }

      private def mapToScala(cds: List[ColumnDescriptor], rs: ResultSet)(using
          m: Mirror.ProductOf[A]
      ): A = {
        val values = cds.map { cd =>
          readValueFromResultSet(cd, rs)
        }
        m.fromProduct(Tuple.fromArray(values.toArray))
      }

      private def readValueFromResultSet(
          cd: ColumnDescriptor,
          rs: ResultSet
      ): Any = {
        if (cd.dataType != JDBCType.ARRAY) {
          if (cd.nullable) {
            Option(cd.reader.read(rs.getObject(cd.index)))
          } else {
            cd.reader.read(rs.getObject(cd.index))
          }
        } else {
          handleArrayFromResultSet(cd, rs)
        }
      }

      private def handleArrayFromResultSet(
          cd: ColumnDescriptor,
          rs: ResultSet
      ): List[?] = {
        val array       = rs.getArray(cd.index)
        val arrayReader = JDBCReader.getJdbcReader(array.getBaseType())
        val scalaArray  = array.getArray().asInstanceOf[Array[?]]
        scalaArray.toList.map(v => arrayReader.read(v))
      }

      private def getColumnLabels[A <: Product](
          removePK: Boolean = false
      ): String = {
        val cols: Seq[String] = {
          if (properties.columnNames.isEmpty) {
            getColumnNames[m.MirroredElemLabels]
          } else {
            properties.columnNames
          }
        }
        val columnNames = if (removePK) {
          cols.filterNot(col => primaryKey.columnNames.contains(col))
        } else {
          cols
        }
        if (properties.isNamingSpecial) {
          columnNames
            .map(col =>
              s"${dialect.specialIdentifierCharacter}$col${dialect.specialIdentifierCharacter}"
            )
            .mkString(",")
        } else {
          columnNames.mkString(",")
        }
      }
    }
  }

  // private inline def getColumnNames[L <: Tuple]: List[String] = {
  //   inline erasedValue[L] match {
  //     case _: EmptyTuple   => List[String]()
  //     case lab: (lh *: lt) =>
  //       val labelName = constValue[lh].toString()
  //       labelName +: getColumnNames[lt]
  //   }
  // }

  // private inline def fieldNamesOf[A](using
  //     m: Mirror.ProductOf[A]
  // ): List[String] =
  //   constValueTuple[m.MirroredElemLabels].toList.asInstanceOf[List[String]]

}
