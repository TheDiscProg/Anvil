package io.github.thediscprog.anvil.annotations

import scala.quoted.*
import scala.quoted.{Expr, Quotes}
import scala.annotation.nowarn

object PrimaryKeyAnnotation {

  inline def getPrimaryKeyNames[A]: PrimaryKeyInfo =
    ${ getPrimaryKeyNamesImpl[A] }

  private def getPrimaryKeyNamesImpl[T: Type](using
      q: Quotes
  ): Expr[PrimaryKeyInfo] = {
    import q.reflect.*
    val typeSymbol           = TypeRepr.of[T].typeSymbol
    val primaryKeyAnnotation =
      typeSymbol.getAnnotation(TypeRepr.of[PrimaryKey].typeSymbol)
    primaryKeyAnnotation match
      case Some(Apply(_, List(keyTypeTerm, listTerm, autoGenTerm))) =>
        val (keyTypeOption, keyTypeExpr, columnNamesExpr, autoGeneratedExpr) =
          extractAnnotationValues(keyTypeTerm, listTerm, autoGenTerm)
        val check =
          doSanityCheck(keyTypeOption, columnNamesExpr, autoGeneratedExpr)
        if (!check.valueOrAbort) {
          report.error(
            s"Sanity Check Failed on Primary key annotation [${check.valueOrAbort}]"
          )
          '{ PrimaryKeyInfo(PrimaryKeyType.SINGLE, Nil, false) }
        } else {
          '{
            PrimaryKeyInfo($keyTypeExpr, $columnNamesExpr, $autoGeneratedExpr)
          }
        }
      case _ =>
        report.error(s"No @PrimaryKey annotation found on $typeSymbol")
        '{ PrimaryKeyInfo(PrimaryKeyType.SINGLE, Nil, false) }
  }

  /** We could create a single method and match the Term to one of the supported
    * values, but we would get a warning as the term.AsExpr tries to convert a
    * Term into Expr[A], but the compiler cannot guarantee that the type A is
    * known at that point. Hence, We now have specific methods to extract
    * annotation values explicitly. It also enables us to add constraints around
    * primary keys.
    */
  private def doSanityCheck(
      keyTypeOption: Option[String],
      columnNamesExpr: Expr[List[String]],
      autoGeneratedExpr: Expr[Boolean]
  )(using q: Quotes): Expr[Boolean] = {
    import q.reflect.*
    val columnNames   = columnNamesExpr.valueOrAbort
    val autoGenerated = autoGeneratedExpr.valueOrAbort
    val keyType       = keyTypeOption match
      case Some(value) =>
        value match
          case "SINGLE"      => PrimaryKeyType.SINGLE
          case "COMPOSITE"   => PrimaryKeyType.COMPOSITE
          case "UNSUPPORTED" =>
            report.error(s"Primary Key of type UNSUPPORTED is not supported")
            PrimaryKeyType.UNSUPPORTED
      case None =>
        report.error(s"Primary Key of type ${keyTypeOption} is not supported")
        PrimaryKeyType.UNSUPPORTED
    if (keyType == PrimaryKeyType.UNSUPPORTED)
      Expr(false)
    if (keyType == PrimaryKeyType.SINGLE && columnNames.size > 1) {
      report.error(
        s"The primary key is defined as a single column but more than one column names have been defined"
      )
      Expr(false)
    }
    if (keyType == PrimaryKeyType.COMPOSITE && autoGenerated) {
      report.error(
        s"The primary key is defined as a composite, which cannot have auto-generated primary keys"
      )
      Expr(false)
    }
    if (keyType == PrimaryKeyType.COMPOSITE && columnNames.size == 1) {
      report.error(
        s"The primary key is defined as a composite but only one column names have been given"
      )
      Expr(false)
    }
    Expr(true)
  }

  private def extractAnnotationValues(using
      q: Quotes
  )(
      keyTypeTerm: q.reflect.Term,
      listTerm: q.reflect.Term,
      autoGenTerm: q.reflect.Term
  ): (
      Option[String],
      Expr[PrimaryKeyType],
      Expr[List[String]],
      Expr[Boolean]
  ) = {
    val keyName           = extractKeyTypeName(keyTypeTerm)
    val keyTypeExpr       = extractKeyType(keyTypeTerm)
    val columnNamesExpr   = extractColumnNames(listTerm)
    val autoGeneratedExpr = extractBooleanValue(autoGenTerm)
    (keyName, keyTypeExpr, columnNamesExpr, autoGeneratedExpr)
  }

  private def extractKeyType(using
      q: Quotes
  )(term: q.reflect.Term): Expr[PrimaryKeyType] = {
    import q.reflect.*
    term.asExpr match {
      case '{ PrimaryKeyType.SINGLE }    => '{ PrimaryKeyType.SINGLE }
      case '{ PrimaryKeyType.COMPOSITE } => '{ PrimaryKeyType.COMPOSITE }
      case _                             =>
        report.error(
          s"Unsupported or not allowed to use ${term.show} for Primary Key type"
        )
        '{ PrimaryKeyType.UNSUPPORTED }
    }
  }

  private def extractKeyTypeName(using
      q: Quotes
  )(term: q.reflect.Term): Option[String] = {
    import q.reflect.*
    term match {
      case Ident(name) => Some(term.symbol.name)
      case _           =>
        report.error(s"Error extracting KeyType name from ${term.show}")
        None
    }
  }

  @nowarn
  private def extractColumnNames(using
      q: Quotes
  )(term: q.reflect.Term): Expr[List[String]] = {
    import q.reflect.*
    val listExpr = term.asExpr match
      case expr: Expr[List[String]] => expr
      case _                        =>
        report.error(
          s"Unable to extract Primary Key column name/s: [${term.show}]"
        )
        Expr(Nil)
    listExpr
  }

  @nowarn
  private def extractBooleanValue(using
      q: Quotes
  )(flag: q.reflect.Term): Expr[Boolean] = {
    import q.reflect.*
    flag.asExpr match
      case expr: Expr[Boolean] => expr
      case _                   =>
        report.error(
          s"Unexpected boolen value ${flag.show} in @PrimaryKey annotation"
        )
        Expr(false)
  }

}
